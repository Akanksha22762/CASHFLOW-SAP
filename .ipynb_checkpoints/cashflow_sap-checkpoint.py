# -*- coding: utf-8 -*-
"""CASHFLOW _SAP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tgio4rPQoZHFmrQ05Sz8rYzZ03UE1vx_
"""

import pandas as pd
import sys
import os

# Fix Unicode encoding for Windows console
if sys.platform.startswith('win'):
    import io
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

# Set pandas options to avoid warnings
pd.options.mode.chained_assignment = None

try:
    bank = pd.read_excel('steel_plant_bank_statement.xlsx')
    print("Bank statement loaded successfully")
except Exception as e:
    print(f"Error loading bank statement: {e}")
    # Create empty dataframe if file doesn't exist
    bank = pd.DataFrame(columns=['Date', 'Description', 'Amount', 'Type'])

try:
    ap_ar_data = pd.read_excel('steel_plant_ap_ar_data.xlsx')
    print("AP/AR data loaded successfully")
except Exception as e:
    print(f"Error loading AP/AR data: {e}")
    # Create empty dataframe if file doesn't exist
    ap_ar_data = pd.DataFrame(columns=['Date', 'Description', 'Type', 'Amount', 'Status'])

try:
    master_excel = "steel_plant_master_data.xlsx"
    chart_of_accounts_data = pd.read_excel(master_excel, sheet_name="Chart of Accounts")
    customers_data = pd.read_excel(master_excel, sheet_name="Customers")
    vendors_data = pd.read_excel(master_excel, sheet_name="Vendors")
    revenue_centres_data = pd.read_excel(master_excel, sheet_name="Revenue Centres")
    cost_centres_data = pd.read_excel(master_excel, sheet_name="Cost Centres")
    print("Master data loaded successfully")
except Exception as e:
    print(f"Error loading master data: {e}")
    # Create empty dataframes if master file doesn't exist
    chart_of_accounts_data = pd.DataFrame()
    customers_data = pd.DataFrame()
    vendors_data = pd.DataFrame()
    revenue_centres_data = pd.DataFrame()
    cost_centres_data = pd.DataFrame()

try:
    transactions_data = pd.read_excel(r"steel_plant_transactions.xlsx")
    print("Transactions data loaded successfully")
    print(f"Shape: {transactions_data.shape}")
    print(f"Columns: {transactions_data.columns.tolist()}")
except Exception as e:
    print(f"Error loading transactions data: {e}")
    # Create empty dataframe if file doesn't exist
    transactions_data = pd.DataFrame()

# Check if we have data to process
if transactions_data.empty:
    print("No transactions data available - exiting")
    exit()

# Clean and prepare data
bank.columns = bank.columns.str.strip()
bank['Date'] = pd.to_datetime(bank['Date'], format='%Y-%m-%d', errors='coerce')
bank['Amount'] = bank['Amount'].astype(float)

transactions_data.columns = transactions_data.columns.str.strip()
transactions_data['Date'] = pd.to_datetime(transactions_data['Date'], format='%Y-%m-%d', errors='coerce')

# Handle column names properly
print("Available columns:", transactions_data.columns.tolist())

# Check if Amount column exists, if not try Amount (INR)
if 'Amount' not in transactions_data.columns:
    if 'Amount (INR)' in transactions_data.columns:
        transactions_data.rename(columns={'Amount (INR)': 'Amount'}, inplace=True)
        print("Renamed 'Amount (INR)' to 'Amount'")
    else:
        print("Warning: No Amount column found!")
        # Create a default Amount column if none exists
        transactions_data['Amount'] = 0

# Check if Balance column exists, if not try Balance (INR)
if 'Balance' not in transactions_data.columns:
    if 'Balance (INR)' in transactions_data.columns:
        transactions_data.rename(columns={'Balance (INR)': 'Balance'}, inplace=True)
        print("Renamed 'Balance (INR)' to 'Balance'")
    else:
        print("Warning: No Balance column found!")
        # Create a default Balance column if none exists
        transactions_data['Balance'] = 0

# Now safely convert to numeric
transactions_data['Amount'] = pd.to_numeric(transactions_data['Amount'], errors='coerce')
transactions_data['Balance'] = pd.to_numeric(transactions_data['Balance'], errors='coerce')

ap_ar_data.columns = ap_ar_data.columns.str.strip()
ap_ar_data['Date'] = pd.to_datetime(ap_ar_data['Date'], format='%Y-%m-%d', errors='coerce')

def categorize_transaction(desc):
    desc = desc.lower()
    if any(k in desc for k in [
        'sale', 'customer', 'receipt', 'income', 'commission',
        'vendor', 'raw material', 'utility', 'payable', 'service',
        'electricity', 'water', 'fuel', 'interest', 'advance',
        'spare', 'logistics', 'packaging', 'maintenance',
        'security', 'cleaning', 'calibration', 'office supplies',
        'consultancy', 'training', 'insurance', 'tools',
        'uniforms', 'printing', 'courier', 'canteen',
        'payroll', 'salary', 'wages'
    ]):
        return 'Operating'

    elif any(k in desc for k in ['machinery', 'equipment', 'capital']):
        return 'Investing'

    elif any(k in desc for k in [
        'loan', 'tds', 'gst', 'dividend', 'equity',
        'pf', 'provident', 'esi', 'lwf', 'royalty'
    ]):
        return 'Financing'

    elif 'opening' in desc:
        return 'Opening'

    elif 'closing' in desc:
        return 'Closing'

    else:
        return 'Uncategorized'

transactions_data['Cash Flow Category'] = transactions_data['Description'].astype(str).apply(categorize_transaction)

def inflow(row):
    # Handle both Amount and Amount (INR) columns
    amount_col = 'Amount' if 'Amount' in row.index else 'Amount (INR)'
    if amount_col in row.index:
        return row[amount_col] if str(row['Type']).lower() in ['inward', 'credit'] else 0
    else:
        return 0

def outflow(row):
    # Handle both Amount and Amount (INR) columns  
    amount_col = 'Amount' if 'Amount' in row.index else 'Amount (INR)'
    if amount_col in row.index:
        return row[amount_col] if str(row['Type']).lower() in ['outward', 'debit'] else 0
    else:
        return 0

# Apply the functions
# Normalize Type values to avoid mismatch in inflow/outflow logic
def normalize_type(val):
    val = str(val).strip().lower()
    if val in ['credit', 'cr', 'in', 'inward']:
        return 'inward'
    elif val in ['debit', 'dr', 'out', 'outward']:
        return 'outward'
    else:
        return 'unknown'

transactions_data['NormalizedType'] = transactions_data['Type'].apply(normalize_type)

# Ensure Amount column is properly populated
if ('Amount' not in transactions_data.columns or
    transactions_data['Amount'].isnull().all() or
    transactions_data['Amount'].sum() == 0) and 'Amount (INR)' in transactions_data.columns:
    transactions_data['Amount'] = transactions_data['Amount (INR)']
transactions_data['Amount'] = pd.to_numeric(transactions_data['Amount'], errors='coerce').fillna(0)

def inflow(row):
    return row['Amount'] if row.get('NormalizedType') == 'inward' else 0

def outflow(row):
    return row['Amount'] if row.get('NormalizedType') == 'outward' else 0

transactions_data['Cash Inflow'] = transactions_data.apply(inflow, axis=1)
transactions_data['Cash Outflow'] = transactions_data.apply(outflow, axis=1)
transactions_data['Net Flow'] = transactions_data['Cash Inflow'] - transactions_data['Cash Outflow']

# Print diagnostics
print("üîç Sample after inflow/outflow calculation:")
print(transactions_data[['Date', 'Description', 'Type', 'NormalizedType', 'Amount', 'Cash Inflow', 'Cash Outflow', 'Net Flow']].head(10))

# Fill NaN values with 0
transactions_data['Cash Inflow'] = transactions_data['Cash Inflow'].fillna(0)
transactions_data['Cash Outflow'] = transactions_data['Cash Outflow'].fillna(0)
transactions_data['Net Flow'] = transactions_data['Net Flow'].fillna(0)

CHART_OF_ACCOUNTS = {
    1000: {'name': 'Cash', 'type': 'Asset'},
    1100: {'name': 'Accounts Receivable', 'type': 'Asset'},
    1200: {'name': 'Inventory', 'type': 'Asset'},
    1300: {'name': 'Prepaid Expenses', 'type': 'Asset'},
    2000: {'name': 'Accounts Payable', 'type': 'Liability'},
    2100: {'name': 'Accrued Expenses', 'type': 'Liability'},
    3000: {'name': 'Revenue', 'type': 'Income'},
    3100: {'name': 'Scrap Sales', 'type': 'Income'},
    4000: {'name': 'Cost of Goods Sold', 'type': 'Expense'},
    4100: {'name': 'Utilities Expense', 'type': 'Expense'},
    4200: {'name': 'Maintenance Expense', 'type': 'Expense'},
    4300: {'name': 'Salaries Expense', 'type': 'Expense'},
}

CASH_ORIGIN_GL_ACCOUNT = {
    'CUSTOMER_SALES': 3000,
    'MATERIAL_SALES': 3100,
    'SUPPLIER_PAYMENT': 2000,
    'MATERIAL_PURCHASE': 4000,
    'UTILITIES': 4100,
    'MAINTENANCE': 4200,
    'PAYROLL': 4300,
    'INTEREST': 2100,
    'FINANCING': 2100,
    'TAX': 2100,
    'GOVT_GRANT': 3000,
    'ROYALTY': 2100,
    'SERVICES': 4200,
    'LOGISTICS': 4200,
    'ADVANCE_RECEIVED': 1100
}

GL_ACCOUNT_MAPPING = {
    'cash': 1000,
    'customer': 1100,
    'advance': 1100,
    'sale': 3000,
    'invoice': 3000,
    'commission': 3000,
    'scrap': 3100,
    'raw material': 4000,
    'fuel': 4000,
    'coal': 4000,
    'electricity': 4100,
    'water': 4100,
    'utility': 4100,
    'maintenance': 4200,
    'repair': 4200,
    'salary': 4300,
    'payroll': 4300,
    'wage': 4300,
    'tds': 2100,
    'gst': 2100,
    'esi': 2100,
    'pf': 2100,
    'equipment': 1200,
    'machinery': 1200,
    'vendor': 2000,
    'loan': 2100,
    'interest': 2100,
    'grant': 3000,
    'royalty': 2100,
    'cleaning': 4200,
    'transport': 4200,
    'consultancy': 4200,
    'canteen': 4200,
    'training': 4200,
    'security': 4200,
    'freight': 4200,
    'insurance': 4200,
    'bank charge': 4200
}

CASH_ORIGIN_MAPPING = {
    'sale': 'CUSTOMER_SALES',
    'invoice': 'CUSTOMER_SALES',
    'customer': 'CUSTOMER_SALES',
    'advance': 'ADVANCE_RECEIVED',
    'vendor': 'SUPPLIER_PAYMENT',
    'raw material': 'MATERIAL_PURCHASE',
    'fuel': 'MATERIAL_PURCHASE',
    'coal': 'MATERIAL_PURCHASE',
    'utility': 'UTILITIES',
    'electricity': 'UTILITIES',
    'water': 'UTILITIES',
    'maintenance': 'MAINTENANCE',
    'repair': 'MAINTENANCE',
    'salary': 'PAYROLL',
    'payroll': 'PAYROLL',
    'wage': 'PAYROLL',
    'interest': 'INTEREST',
    'loan': 'FINANCING',
    'tds': 'TAX',
    'gst': 'TAX',
    'esi': 'TAX',
    'pf': 'TAX',
    'grant': 'GOVT_GRANT',
    'royalty': 'ROYALTY',
    'cleaning': 'SERVICES',
    'transport': 'LOGISTICS',
    'consultancy': 'SERVICES',
    'canteen': 'SERVICES',
    'training': 'SERVICES',
    'security': 'SERVICES',
    'scrap': 'MATERIAL_SALES',
    'commission': 'CUSTOMER_SALES',
    'freight': 'LOGISTICS',
    'insurance': 'SERVICES',
    'bank charge': 'SERVICES'
}

VENDOR_CATEGORIES = {
    'Capex': ['machinery', 'equipment', 'capital', 'asset', 'tools', 'calibration', 'safety', 'labor welfare fund'],
    'Maintenance': ['maintenance', 'repair', 'service', 'cleaning', 'pest control', 'lubricants', 'fuel', 'spare parts', 'packaging'],
    'Utilities': ['electricity', 'water', 'utility', 'fuel'],
    'Payroll': ['payroll', 'salary', 'wages', 'provident fund', 'esi', 'labor welfare fund', 'pf', 'esi payment'],
    'Tax': ['tds', 'gst', 'tax', 'statutory refund'],
    'Logistics': ['freight', 'logistics', 'transport', 'courier'],
    'Services': ['consultancy', 'security', 'training', 'canteen', 'insurance', 'it services', 'cleaning services', 'office supplies', 'printing'],
    'Sales': ['customer payment', 'export incentive', 'royalty payment', 'government grant', 'interest credit'],
    'Scrap': ['scrap disposal'],
}

def get_gl_account(description):
    desc = str(description).lower()
    for keyword, account_code in GL_ACCOUNT_MAPPING.items():
        if keyword in desc:
            return account_code
    return None

def get_account_type(gl_account):
    return CHART_OF_ACCOUNTS.get(gl_account, {}).get('type') if gl_account else None

def get_account_name(gl_account):
    return CHART_OF_ACCOUNTS.get(gl_account, {}).get('name') if gl_account else None

def get_cash_origin(description):
    desc = str(description).lower()
    for keyword, origin in CASH_ORIGIN_MAPPING.items():
        if keyword in desc:
            return origin
    return 'OTHER'

def get_vendor_category(description):
    desc = str(description).lower()
    for category, keywords in VENDOR_CATEGORIES.items():
        if any(k in desc for k in keywords):
            return category
    return 'Uncategorized'

# Create structured mapping output
rows = []
for keyword, gl_account_code in GL_ACCOUNT_MAPPING.items():
    gl_account_name = CHART_OF_ACCOUNTS.get(gl_account_code, {}).get('name', 'Unknown')
    origin_key = CASH_ORIGIN_MAPPING.get(keyword, 'OTHER')
    origin_gl_code = CASH_ORIGIN_GL_ACCOUNT.get(origin_key, None)
    origin_gl_name = CHART_OF_ACCOUNTS.get(origin_gl_code, {}).get('name', 'Unknown') if origin_gl_code else 'Unknown'

    rows.append({
        'G/L Account': gl_account_code,
        'Description': gl_account_name,
        'Cash Origin Account': origin_gl_code,
        'Cash Origin Description': origin_gl_name
    })

# Create and export the DataFrame
mapping_df = pd.DataFrame(rows).drop_duplicates()
mapping_df.to_excel("data/gl_cash_origin_mapping_output_fixed.xlsx", index=False)

# Apply categorizations to transactions
transactions_data['GL_Account'] = transactions_data['Description'].apply(get_gl_account)
transactions_data['Account_Type'] = transactions_data['GL_Account'].apply(get_account_type)
transactions_data['Account_Name'] = transactions_data['GL_Account'].apply(get_account_name)
transactions_data['Cash_Origin'] = transactions_data['Description'].apply(get_cash_origin)
transactions_data['Vendor_Category'] = transactions_data['Description'].apply(get_vendor_category)

print("Unique GL Accounts:", transactions_data['GL_Account'].nunique())
print("Unique Cash Origins:", transactions_data['Cash_Origin'].nunique())
print("Unique Vendor Categories:", transactions_data['Vendor_Category'].nunique())
print("Unique Cash Flow Categories:", transactions_data['Cash Flow Category'].nunique())

# Calculate balances if missing or incorrect
balance_col = 'Balance' if 'Balance' in transactions_data.columns else 'Balance (INR)'
amount_col = 'Amount' if 'Amount' in transactions_data.columns else 'Amount (INR)'

if balance_col not in transactions_data.columns:
    print("Creating Balance column from Amount column")
    transactions_data['Balance'] = transactions_data[amount_col].cumsum()
    balance_col = 'Balance'

# Fix deprecated fillna method
transactions_data['Cash Flow Category'] = transactions_data['Cash Flow Category'].fillna('Unknown')
transactions_data['Cash Inflow'] = transactions_data['Cash Inflow'].fillna(0)
transactions_data['Cash Outflow'] = transactions_data['Cash Outflow'].fillna(0)
transactions_data[amount_col] = transactions_data[amount_col].fillna(0)

# Use ffill() instead of fillna(method='ffill')
transactions_data[balance_col] = transactions_data[balance_col].ffill()

# Calculate summaries
category_summary = transactions_data.groupby('Cash Flow Category')[['Cash Inflow', 'Cash Outflow', 'Net Flow']].sum().reset_index()
gl_summary = transactions_data.groupby(['GL_Account', 'Account_Name'])[['Cash Inflow', 'Cash Outflow', 'Net Flow']].sum().reset_index()
vendor_summary = transactions_data.groupby('Vendor_Category')[['Cash Inflow', 'Cash Outflow', 'Net Flow']].sum().reset_index()
daily_summary = transactions_data.groupby('Date')[['Cash Inflow', 'Cash Outflow', 'Net Flow']].sum().reset_index()

# Create visualization (optional - skip on error)
try:
    import matplotlib.pyplot as plt
    import seaborn as sns
    
    sns.set(style="whitegrid")
    
    # Create plots
    fig, axes = plt.subplots(2, 1, figsize=(12, 10))
    
    # Bar chart
    category_summary.plot(
        x='Cash Flow Category',
        kind='bar',
        stacked=False,
        ax=axes[0],
        title='Cash Inflow vs Outflow by Category',
        color=['seagreen', 'tomato', 'black']
    )
    
    # Pie chart
    net_flow = transactions_data.groupby('Cash Flow Category')['Net Flow'].sum()
    net_flow = net_flow[net_flow != 0]
    net_flow_abs = net_flow.abs()
    
    if not net_flow_abs.empty:
        net_flow_abs.plot(
            kind='pie',
            autopct='%1.1f%%',
            startangle=90,
            ax=axes[1],
            title='Net Cash Flow Share by Category'
        )
    
    plt.tight_layout()
    plt.savefig('data/cash_flow_charts.png', dpi=150, bbox_inches='tight')
    plt.close()
    print("Charts saved successfully")
    
except Exception as e:
    print(f"Warning: Could not create charts - {e}")

# Save updated transactions
transactions_data.to_csv('data/transactions_data_updated.csv', index=False)
print("Updated transactions saved")

# Calculate cash flow components
customer_collections = transactions_data[transactions_data['Cash_Origin'] == 'CUSTOMER_SALES']['Cash Inflow'].sum()
advance_received = transactions_data[transactions_data['Cash_Origin'].str.contains('ADVANCE', na=False)]['Cash Inflow'].sum()
operating_data = transactions_data[transactions_data['Cash Flow Category'].str.contains('Operating', case=False)]
other_receipts = operating_data['Cash Inflow'].sum() - customer_collections - advance_received
total_operating_inflows = customer_collections + advance_received + other_receipts

vendor_payments = transactions_data[transactions_data['Cash_Origin'].isin(['SUPPLIER_PAYMENT', 'MATERIAL_SALES'])]['Cash Outflow'].sum()
payroll_payments = transactions_data[transactions_data['Cash_Origin'] == 'PAYROLL']['Cash Outflow'].sum()
utility_payments = transactions_data[transactions_data['Description'].str.contains('Electricity|Water|Utility', case=False, na=False)]['Cash Outflow'].sum()
statutory_payments = transactions_data[transactions_data['Cash_Origin'] == 'TAX']['Cash Outflow'].sum()
known_outflows = vendor_payments + payroll_payments + utility_payments + statutory_payments
other_operating_payments = operating_data['Cash Outflow'].sum() - known_outflows
total_operating_outflows = known_outflows + other_operating_payments
net_operating_cash_flow = total_operating_inflows - total_operating_outflows

investing_data = transactions_data[transactions_data['Vendor_Category'].str.contains('Capex|Asset', na=False, case=False)]
asset_purchases = investing_data['Cash Outflow'].sum()
net_investing_cash_flow = -asset_purchases

financing_data = transactions_data[transactions_data['Cash Flow Category'].str.contains('Financing', na=False)]
debt_service_payments = financing_data['Cash Outflow'].sum()
net_financing_cash_flow = -debt_service_payments

# Calculate opening and closing balances with proper column names
balance_col = 'Balance' if 'Balance' in transactions_data.columns else 'Balance (INR)'
amount_col = 'Amount' if 'Amount' in transactions_data.columns else 'Amount (INR)'

if len(transactions_data) > 0:
    # Find opening balance (first non-zero balance or calculate from first transaction)
    first_row = transactions_data.iloc[0]
    if balance_col in transactions_data.columns:
        opening_balance = first_row[balance_col] - first_row[amount_col]
    else:
        opening_balance = 0
    
    # Find closing balance (last balance)
    if balance_col in transactions_data.columns:
        closing_balance = transactions_data.iloc[-1][balance_col]
    else:
        closing_balance = transactions_data[amount_col].sum()
else:
    opening_balance = 0
    closing_balance = 0
net_change_in_cash = net_operating_cash_flow + net_investing_cash_flow + net_financing_cash_flow
calculated_closing_balance = opening_balance + net_change_in_cash

# Create detailed cash flow statement
detailed_cashflow = pd.DataFrame([
    ['Operating Activities', 'Cash Receipts from Customers', customer_collections],
    ['Operating Activities', 'Cash Received as Advances', advance_received],
    ['Operating Activities', 'Other Operating Receipts', other_receipts],
    ['Operating Activities', 'Total Operating Inflows', total_operating_inflows],
    ['Operating Activities', 'Cash Paid to Suppliers (incl. Scrap)', -vendor_payments],
    ['Operating Activities', 'Cash Paid to Employees', -payroll_payments],
    ['Operating Activities', 'Cash Paid for Utilities', -utility_payments],
    ['Operating Activities', 'Cash Paid for Statutory', -statutory_payments],
    ['Operating Activities', 'Other Operating Payments', -other_operating_payments],
    ['Operating Activities', 'Total Operating Outflows', -total_operating_outflows],
    ['Operating Activities', 'Net Operating Cash Flow', net_operating_cash_flow],
    ['Investing Activities', 'Purchase of Fixed Assets', -asset_purchases],
    ['Investing Activities', 'Net Investing Cash Flow', net_investing_cash_flow],
    ['Financing Activities', 'Debt Service Payments', -debt_service_payments],
    ['Financing Activities', 'Net Financing Cash Flow', net_financing_cash_flow],
    ['Summary', 'Net Change in Cash', net_change_in_cash],
    ['Summary', 'Cash at Beginning of Period', opening_balance],
    ['Summary', 'Cash at End of Period', closing_balance],
    ['Summary', 'Calculated Ending Balance', calculated_closing_balance]
], columns=['Section', 'Description', 'Amount'])

import pandas as pd
import numpy as np

def prepare_detailed_cash_flow_statement_with_vendor_categories(df):
    print("Preparing Cash Flow Statement with Vendor Category-wise Details...")

    # Extract vendor category from Description for vendor payments
    def extract_vendor_category(desc):
        if isinstance(desc, str) and desc.startswith('Vendor Payment -'):
            return desc.replace('Vendor Payment -', '').strip()
        else:
            return np.nan

    df['Vendor_Category_Extracted'] = df['Description'].apply(extract_vendor_category)

    # Operating activities data
    operating_data = df[df['Cash Flow Category'].str.contains('Operating', na=False)]

    # Operating inflows
    customer_collections = operating_data[operating_data['Cash_Origin'] == 'CUSTOMER_SALES']['Cash Inflow'].sum()
    advance_received = operating_data[operating_data['Cash_Origin'].str.contains('ADVANCE', na=False)]['Cash Inflow'].sum()
    other_receipts = operating_data['Cash Inflow'].sum() - customer_collections - advance_received

    # Vendor payments grouped by category
    vendor_payments = operating_data[operating_data['Vendor_Category_Extracted'].notna()]
    vendor_outflows = vendor_payments.groupby('Vendor_Category_Extracted')['Cash Outflow'].sum().reset_index()
    vendor_outflows = vendor_outflows.sort_values(by='Cash Outflow', ascending=False)

    total_vendor_payments = vendor_outflows['Cash Outflow'].sum()

    # Other operating outflows
    payroll_payments = operating_data[operating_data['Cash_Origin'] == 'PAYROLL']['Cash Outflow'].sum()
    utility_payments = operating_data[operating_data['Cash_Origin'] == 'UTILITIES']['Cash Outflow'].sum()
    statutory_payments = operating_data[operating_data['Cash_Origin'] == 'TAX']['Cash Outflow'].sum()
    other_payments = operating_data['Cash Outflow'].sum() - total_vendor_payments - payroll_payments - utility_payments - statutory_payments

    # Total operating inflows and outflows
    total_operating_inflows = customer_collections + advance_received + other_receipts
    total_operating_outflows = total_vendor_payments + payroll_payments + utility_payments + statutory_payments + other_payments
    net_operating_cash_flow = total_operating_inflows - total_operating_outflows

    # Investing activities
    investing_data = df[df['Cash Flow Category'].str.contains('Investing', na=False)]
    asset_purchases = investing_data['Cash Outflow'].sum()
    net_investing_cash_flow = -asset_purchases

    # Financing activities
    financing_data = df[df['Cash Flow Category'].str.contains('Financing', na=False)]
    debt_service = financing_data['Cash Outflow'].sum()
    net_financing_cash_flow = -debt_service

    # Opening and closing balances with proper column handling
    balance_col = 'Balance' if 'Balance' in df.columns else 'Balance (INR)'
    amount_col = 'Amount' if 'Amount' in df.columns else 'Amount (INR)'
    
    if len(df) > 0:
        if balance_col in df.columns and amount_col in df.columns:
            opening_balance = df.iloc[0][balance_col] - df.iloc[0][amount_col]
            closing_balance = df.iloc[-1][balance_col]
        else:
            opening_balance = 0
            closing_balance = 0
    else:
        opening_balance = 0
        closing_balance = 0

    # Net change in cash
    net_change_in_cash = net_operating_cash_flow + net_investing_cash_flow + net_financing_cash_flow

    # Prepare main operating rows
    main_operating_rows = [
        ['Operating Activities', 'Cash Receipts from Customers', customer_collections],
        ['Operating Activities', 'Cash Received as Advances', advance_received],
        ['Operating Activities', 'Other Operating Receipts', other_receipts],
        ['Operating Activities', 'Total Operating Inflows', total_operating_inflows],
        ['Operating Activities', 'Cash Paid to Employees', -payroll_payments],
        ['Operating Activities', 'Cash Paid for Utilities', -utility_payments],
        ['Operating Activities', 'Cash Paid for Statutory', -statutory_payments],
        ['Operating Activities', 'Other Operating Payments', -other_payments],
        ['Operating Activities', 'Total Operating Outflows', -total_operating_outflows],
        ['Operating Activities', 'Net Operating Cash Flow', net_operating_cash_flow]
    ]

    detailed_cashflow = pd.DataFrame(main_operating_rows, columns=['Section', 'Description', 'Amount'])

    # Create vendor payment rows to insert
    vendor_payment_rows = []
    for _, row in vendor_outflows.iterrows():
        desc = f"Cash Paid to Vendor Category: {row['Vendor_Category_Extracted']}"
        vendor_payment_rows.append(['Operating Activities', desc, -row['Cash Outflow']])

    vendor_payment_df = pd.DataFrame(vendor_payment_rows, columns=['Section', 'Description', 'Amount'])

    # Insert vendor payment rows before 'Total Operating Outflows'
    total_outflows_index = detailed_cashflow[detailed_cashflow['Description'] == 'Total Operating Outflows'].index[0]

    detailed_cashflow = pd.concat([
        detailed_cashflow.iloc[:total_outflows_index],
        vendor_payment_df,
        detailed_cashflow.iloc[total_outflows_index:]
    ]).reset_index(drop=True)

    # Investing Activities summary
    investing_activities = {
        'Purchase of Fixed Assets': -asset_purchases,
        'Net Investing Cash Flow': net_investing_cash_flow
    }

    # Financing Activities summary
    financing_activities = {
        'Debt Service Payments': -debt_service,
        'Net Financing Cash Flow': net_financing_cash_flow
    }

    # Summary section
    summary = {
        'Net Change in Cash': net_change_in_cash,
        'Cash at Beginning of Period': opening_balance,
        'Cash at End of Period': closing_balance,
        'Calculated Ending Balance': opening_balance + net_change_in_cash
    }

    return {
        'Operating Activities': detailed_cashflow,
        'Investing Activities': investing_activities,
        'Financing Activities': financing_activities,
        'Summary': summary
    }


def extract_vendor_category(desc):
    if isinstance(desc, str) and desc.startswith('Vendor Payment -'):
        return desc.replace('Vendor Payment -', '').strip()
    else:
        return np.nan

transactions_data['Vendor_Category_Extracted'] = transactions_data['Description'].apply(extract_vendor_category)


# Generate detailed cash flow statement
result = prepare_detailed_cash_flow_statement_with_vendor_categories(transactions_data)

print("OPERATING ACTIVITIES")
print(result['Operating Activities'].to_string(index=False))

print("\nINVESTING ACTIVITIES")
investing_df = pd.DataFrame(result['Investing Activities'].items(), columns=['Description', 'Amount'])
print(investing_df.to_string(index=False))

print("\nFINANCING ACTIVITIES")
financing_df = pd.DataFrame(result['Financing Activities'].items(), columns=['Description', 'Amount'])
print(financing_df.to_string(index=False))

print("\nCASH FLOW SUMMARY")
summary_df = pd.DataFrame(result['Summary'].items(), columns=['Metric', 'Value'])
print(summary_df.to_string(index=False))

# Create full text report
operating_str = "OPERATING ACTIVITIES\n" + result['Operating Activities'].to_string(index=False)
investing_df = pd.DataFrame(result['Investing Activities'].items(), columns=['Description', 'Amount'])
investing_str = "\n\nINVESTING ACTIVITIES\n" + investing_df.to_string(index=False)
financing_df = pd.DataFrame(result['Financing Activities'].items(), columns=['Description', 'Amount'])
financing_str = "\n\nFINANCING ACTIVITIES\n" + financing_df.to_string(index=False)
summary_df = pd.DataFrame(result['Summary'].items(), columns=['Metric', 'Value'])
summary_str = "\n\nCASH FLOW SUMMARY\n" + summary_df.to_string(index=False)

full_report = operating_str + investing_str + financing_str + summary_str

# Save to a .txt file
with open("data/cash_flow_statement.txt", "w", encoding="utf-8") as file:
    file.write(full_report)

print("\nText report saved as 'cash_flow_statement.txt'")

# Bank reconciliation section
import numpy as np

# Only proceed with reconciliation if we have both datasets
if not bank.empty and not ap_ar_data.empty:
    print("Starting bank reconciliation...")
    
    ap_ar_data['Date'] = pd.to_datetime(ap_ar_data['Date']).dt.normalize()
    bank['Date'] = pd.to_datetime(bank['Date']).dt.normalize()

    gl_account_map = {
        'Accounts Payable': 2000,
        'Accounts Receivable': 1100,
        'Revenue': 3000,
        'Scrap Sale': 3100,
        'Maintenance Service Charges': 4200,
        'Utility Bill Payment': 4100,
        'Commission Income': 3000,
        'Export Sale - Europe': 3000,
        'Miscellaneous Income': 3000,
        'IT Services Invoice': 3000,
        'Cost of Goods Sold': 4000,
        'Cash': 1000,
        'Prepaid Expenses': 1300,
        'Accrued Expenses': 2100,
        'Salaries Expense': 4300,
    }

    ap_ar_data['GL_Account'] = ap_ar_data['Type'].map(gl_account_map)

    def map_gl_account_bank(desc):
        desc = str(desc).lower()
        if 'vendor' in desc:
            return 2000  # Accounts Payable
        elif 'utility' in desc:
            return 4100  # Utilities Expense
        elif 'scrap sale' in desc:
            return 3100  # Revenue - Scrap Sales
        elif 'maintenance' in desc:
            return 4200  # Maintenance Expense
        elif 'loan' in desc:
            return 2100  # Accrued Expenses or Loan
        else:
            return 1000  # Cash or default account

    bank['GL_Account'] = bank['Description'].apply(map_gl_account_bank)
else:
    print("Skipping bank reconciliation - missing data files")

# Reconciliation logic
# Reconciliation logic
if not bank.empty and not ap_ar_data.empty:
    try:
        from fuzzywuzzy import fuzz
        print("Running fuzzy matching reconciliation...")
        
        # Clean descriptions
        def clean_desc(desc):
            if not isinstance(desc, str):
                return "unknown"
            desc = desc.lower()
            if "vendor" in desc or "supplier" in desc:
                return "vendor payment"
            if "scrap" in desc:
                return "scrap sale"
            if "salary" in desc or "payroll" in desc or "wage" in desc:
                return "salary"
            if "tax" in desc or "gst" in desc or "tds" in desc or "esi" in desc or "pf" in desc or "lwf" in desc:
                return "tax"
            if "electricity" in desc or "water" in desc or "utility" in desc:
                return "utility"
            if "freight" in desc or "logistics" in desc or "transport" in desc:
                return "freight"
            if "loan" in desc or "emi" in desc:
                return "loan"
            if "client" in desc or "invoice" in desc or "sale" in desc or "commission" in desc or "receipt" in desc:
                return "client receipt"
            if "insurance" in desc:
                return "insurance"
            if "maintenance" in desc or "repair" in desc or "service" in desc or "cleaning" in desc or "calibration" in desc:
                return "maintenance"
            if "bank charge" in desc or "bank fee" in desc:
                return "bank charge"
            if "canteen" in desc or "training" in desc or "consultancy" in desc or "security" in desc:
                return "services"
            if "advance" in desc:
                return "advance"
            return "other"

        # Apply cleaning
        bank['Clean_Description'] = bank['Description'].apply(clean_desc)
        ap_ar_data['Clean_Description'] = ap_ar_data['Description'].apply(clean_desc)

        # Round amounts
        bank['Amount'] = bank['Amount'].round(2)
        ap_ar_data['Amount'] = ap_ar_data['Amount'].round(2)

        # Remove duplicates
        bank = bank.drop_duplicates(subset=['Clean_Description', 'Amount'])
        ap_ar_data = ap_ar_data.drop_duplicates(subset=['Clean_Description', 'Amount'])

        # Matching logic
        matches_ap_ar = []
        used_bank_indices = set()

        for _, ap_row in ap_ar_data.iterrows():
            ap_desc = ap_row['Clean_Description']
            ap_amt = ap_row['Amount']

            for idx, bank_row in bank.iterrows():
                if idx in used_bank_indices:
                    continue

                bank_desc = bank_row['Clean_Description']
                bank_amt = bank_row['Amount']
                amt_diff = abs(ap_amt - bank_amt)

                # Exact match
                if ap_desc == bank_desc and amt_diff <= 10000:
                    matches_ap_ar.append({
                        'AP_AR_Description': ap_row['Description'],
                        'AP_AR_Amount': ap_amt,
                        'Bank_Description': bank_row['Description'],
                        'Bank_Amount': bank_amt,
                        'Category': ap_desc,
                        'Amount_Difference': amt_diff,
                        'Confidence': 100
                    })
                    used_bank_indices.add(idx)
                    break

                # Fuzzy match
                else:
                    fuzzy_score = fuzz.partial_ratio(ap_desc, bank_desc)
                    if fuzzy_score >= 85 and amt_diff <= 10000:
                        matches_ap_ar.append({
                            'AP_AR_Description': ap_row['Description'],
                            'AP_AR_Amount': ap_amt,
                            'Bank_Description': bank_row['Description'],
                            'Bank_Amount': bank_amt,
                            'Category': ap_desc,
                            'Amount_Difference': amt_diff,
                            'Confidence': fuzzy_score
                        })
                        used_bank_indices.add(idx)
                        break

        # Convert to DataFrame
        matches_ap_ar_df = pd.DataFrame(matches_ap_ar)
        if not matches_ap_ar_df.empty:
            matches_ap_ar_df = matches_ap_ar_df.drop_duplicates(subset=['AP_AR_Description', 'Bank_Description'])
            matches_ap_ar_df = matches_ap_ar_df.sort_values(by=["Confidence", "Amount_Difference"], ascending=[False, True])

        # Identify unmatched rows
        matched_ap_ar_descriptions = set(matches_ap_ar_df['AP_AR_Description']) if not matches_ap_ar_df.empty else set()
        matched_bank_descriptions = set(matches_ap_ar_df['Bank_Description']) if not matches_ap_ar_df.empty else set()

        unmatched_ap_ar = ap_ar_data[~ap_ar_data['Description'].isin(matched_ap_ar_descriptions)].copy()
        unmatched_bank = bank[~bank['Description'].isin(matched_bank_descriptions)].copy()

        # Second fuzzy matching
        fuzzy_matches = []
        for idx_ar, ar_row in unmatched_ap_ar.iterrows():
            best_score = 0
            best_bank_idx = None
            for idx_bk, bk_row in unmatched_bank.iterrows():
                score = fuzz.token_sort_ratio(str(ar_row['Description']), str(bk_row['Description']))
                amt_diff = abs(ar_row['Amount'] - bk_row['Amount'])
                if score > 80 and amt_diff <= 10000:
                    if score > best_score:
                        best_score = score
                        best_bank_idx = idx_bk
            
            if best_bank_idx is not None:
                fuzzy_matches.append({
                    "AP_AR_Description": ar_row['Description'],
                    "AP_AR_Amount": ar_row['Amount'],
                    "Bank_Description": unmatched_bank.loc[best_bank_idx]['Description'],
                    "Bank_Amount": unmatched_bank.loc[best_bank_idx]['Amount'],
                    "Fuzzy_Score": best_score,
                    "Amount_Difference": abs(ar_row['Amount'] - unmatched_bank.loc[best_bank_idx]['Amount'])
                })

        fuzzy_matches_df = pd.DataFrame(fuzzy_matches)

        # Final unmatched
        fuzzy_matched_ap_ar_desc = set(fuzzy_matches_df['AP_AR_Description']) if not fuzzy_matches_df.empty else set()
        fuzzy_matched_bank_desc = set(fuzzy_matches_df['Bank_Description']) if not fuzzy_matches_df.empty else set()

        final_unmatched_ap_ar = unmatched_ap_ar[~unmatched_ap_ar['Description'].isin(fuzzy_matched_ap_ar_desc)]
        final_unmatched_bank = unmatched_bank[~unmatched_bank['Description'].isin(fuzzy_matched_bank_desc)]

        # Flag unmatched transactions
        final_unmatched_bank['Reconciliation_Status'] = 'Missing in AP/AR'
        final_unmatched_bank['Investigation_Notes'] = ''

        final_unmatched_ap_ar['Reconciliation_Status'] = 'Pending from Bank'
        final_unmatched_ap_ar['Investigation_Notes'] = ''

        # Save results
        final_unmatched_bank.to_excel("data/unmatched_bank_missing_in_ap_ar.xlsx", index=False)
        final_unmatched_ap_ar.to_excel("data/unmatched_ap_ar_pending_in_bank.xlsx", index=False)

        matches_ap_ar_df.to_excel("data/matched_exact_transactions.xlsx", index=False)
        fuzzy_matches_df.to_excel("data/matched_fuzzy_transactions.xlsx", index=False)

        # Combine matches
        final_ap_ar_combined = pd.concat([matches_ap_ar_df, fuzzy_matches_df], ignore_index=True)
        final_ap_ar_combined.to_excel("data/final_ap_ar_transactions.xlsx", index=False)

        print(f"Exact Matches Found: {len(matches_ap_ar_df)}")
        print(f"Fuzzy Matches Found: {len(fuzzy_matches_df)}")
        print(f"Unmatched AP/AR Transactions: {len(final_unmatched_ap_ar)}")
        print(f"Unmatched Bank Transactions: {len(final_unmatched_bank)}")

    except ImportError:
        print("fuzzywuzzy not available - skipping fuzzy matching")
        
    except Exception as e:
        print(f"Error in reconciliation: {e}")
else:
    print("Skipping reconciliation - insufficient data")

print("Processing completed successfully!")